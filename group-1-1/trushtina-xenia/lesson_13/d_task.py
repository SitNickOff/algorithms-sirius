# D. BFS

# Задан неориентированный связный граф. Обойдите его поиском в ширину, стартуя 
# из заданной вершины, и выведите вершины в порядке обхода.

# Формат ввода
# В первой строке дано количество вершин n (1 ≤ n ≤ 10 в 5) и рёбер m (0 ≤ m ≤ 10 в 5). 
# Далее в m строках описаны рёбра графа. Каждое ребро описывается номерами двух 
# вершин u и v (1 ≤ u, v ≤ n). В последней строке дан номер стартовой вершины s (1 ≤ s ≤ n).

# Гарантируется, что в графе нет петель и кратных рёбер.

# Формат вывода
# Выведите вершины в порядке обхода, считая что при запуске от каждой конкретной 
# вершины её соседи будут рассматриваться в порядке возрастания (то есть если вершина 2 
# соединена с 1 и 3, то сначала обход пойдёт в 1, а уже потом в 3).

# Пример 1
# Ввод:
# 4 4
# 1 2
# 2 3
# 3 4
# 1 4
# 3
# Вывод:
# 3 2 4 1 

# Пример 2
# Ввод:
# 2 1
# 2 1
# 1
# Вывод:
# 1 2 

n = 4
m = 4
colors = ['white'] * n
# distance = [None] * n
# previous = [None] * n

def solution(n, m, edges):
    vs = []
    for i in range(n):
        vs.append([0])
    
    for e in edges:
        vs[e[0]-1][0] += 1
        vs[e[0]-1].append(e[1])
    
        # print(f'e: {e}')
        # print(f'vs[e[0]-1]: {vs[e[0]-1]}')
    
    # print(f'vs: {vs}')
    return vs

graph = solution(n, m, [[1, 2], [2, 3], [3, 4], [1, 4]])

def BFS(s):
     planned = []
     planned.append(s)
     print(f'planned: {planned}')

print(graph)
BFS(1)